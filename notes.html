<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Javascript - Weird Parts</title>
    <link rel="stylesheet" href="./style.css">
</head>

<body>
    <div class="bg">
        <h1>Syntax parser</h1>
        <h3>A program that reads js code and translates it to computer readable language.</h3>
        <br />
    </div>

    <div class="bg">
        <h1>Lexical Environment</h1>
        <h3>Where something sits physically in the code you write.<br />
            Lexical Environment exists in which <b>where</b> you write something is important.

            It basically tells where is it written and what surrounds it.

            For example:
            <pre>
        <code>
            var b = "b";

            function abc(){
                 var a = 'a';
            }
        </code>
    </pre>
            <h4> Here <b>variable b</b> is globally available but <b>variable a</b> is available only inside <b>function
                    abc</b>
                that is <b>lexical scope</b> of variable b</h4>
        </h3>

        <br />
    </div>

    <div class="bg">
        <h1>Execution context</h1>
        <h3><b>A wrapper to help manage the code that is running.</b>
            There are lot of lexical environments but <b>which one is running currently</b> is managed by Execution
            code.
            <br />
            It not only contains our code but it also contains things written by syntax parser to run code.
        </h3>

        <br>

        <h1>Objects</h1>
        <h3>Collection of name value pairs

            <pre>
            <code>
                let address = {
                    street : 'Main',
                    apartment : {
                        floor : 2,
                        number : 100
                    }
                };
            </code>
        </pre>

            Here address, street, apartment, floor and number are all name and respective to right their values.
            Value can itself be another object.
        </h3>

        <h3>All primitive types are poperties of object, whereas function in an object is called method.</h3>
    </div>

    <div class="bg">
        <h1>OOP</h1>
        <h3>When we write our code using objects to represent entities, that’s called object-oriented programming, in
            short: “OOP”.</h3>

        <pre>
                <code>
                    const obj = {
                        name : 'Khushbu',
                        sureName : 'Thakur'
                    };


                    function welcomeUser(){
                        alert(`Hi there! Welcome to corona world.`);
                    }

                    obj.welcomeUser = welcomeUser;
                    obj.welcomeUser();
                </code>
            </pre>
    </div>


    <div class="bg">
        <h1>Execution context - GLOBAL</h1>
        <h3>Javascript engine creates <b>Global Object</b> and variable <b>this</b> (setup in memory) whenever our code
            runs because code
            in wrapped inside <i>execution context</i></h3>
    </div>

    <div class="bg">
        <h1>Hoisting</h1>
        <h3>Javascript engine moves functions and variables to the top of the code
            E.g.
            <pre>
                <code>
                    b();

                    console.log(a);
                    
                    var a = "a val";

                    function b(){
                        console.log('b function called');
                    }

                    //output
                  ->  b function called
                  -> undefined

                </code>
            </pre>
            <p>here a and b both are called before they are declared. but still there is no error in console because
                they are moved to the top</p>
        </h3>
        <h3>
            There are <b>two phases</b> which happen during execution;
            <ul type="none">
                <li>
                    1. Creation phases
                </li>
                <li>
                    2. Execution phase
                </li>
            </ul>
            <ul>
                <li> 1. During creation phase -> global object is setup within memory. </li>
                <li> 2. Parser recognizes where we have created variables and functions. </li>
                <li> 3. Set asides memory space for them </li>
                <li> 4. Function is entirely placed in memory i.e. both function and logic inside it </li>
                <li> 5. Whereas in case of variables it only sets memory space and sets value as undefined as it don't
                    know what's it value will be until it is executed
                    i.e. it assigns undefined placeholder for it </li>
            </ul>

            <b>All variables in javascript are initially set to undefined and functions are sitting in memory
                entirely.</b>
            </h5>

            <p>if we use let instead of var then it will throw error instead of showing undefined and will say <br>
                <b> ------------ Cannot access 'a' before initialization ---------</b></p>
    </div>

    <div class="bg">
        <h1>Single threaded - synchronous execution</h1>
        <h3>Single threaded : One command is executed at a time.</h3>
        <h3>synchronous : one at a time and in order that it appears.</h3>
    </div>

    <div class="bg">
        <h1>Invocation</h1>
        <h3>Running a function { by using paranthesis() }. So when we say invoke the function we mean to say run the
            function.</h3>

        <b>So whenever we invoke a function a new execution context is created and put on the top of the stack. The
            execution context on the top is always executed currently.</b>

        <p> When function is executed it gets poped out from the stack.</p>
        <div>
            <img src="./img/function-invocation.gif" class="responsive" />
        </div>
    </div>

    <div class="bg">
        <h1>Scope Chain</h1>
        <img src="./img/scope-chain.png" class="responsive">

        <h3>If we call same function twice, each will get it's own execution context.</h3>
    </div>

    <div class="bg">
        <h1>Scope</h1>

        <h3>Where a variable is available in the code.</h3>
        <h3><b>let</b> is block scope. It is only available inside the current function.</h3>
        <pre>
            <code>
                function a(){
                    let b = true;
                    var c = false;
                }
            </code>
        </pre>

        <h3> <b>let is same as var.</b> It is declared, set to undefined and stored in the memory. <b>However we can't
                use it until the line of code is actually run</b></h3>

        <h4>In above example if we call b variable before it's declaration, it throws reference error.</h4>
        <h3><u>Variable c is available outside <code>function a</code> but variable b is not available as it is declared
                using let. And let is block scoped.</u></h3>
        <h5>A block's in general defined by curly braces. Eg. if statement, for loop, function</h5>

        <pre>
            <code>

            for (let i = 0; i < 3; i++) {
                setTimeout(() => {
                    // here everytime we will get a different variable in memory as let is block scoped
                    console.log(i)
                }, 1);
            }


                /*
                output
                0
                1
                2
                */

            for (var j = 0; j < 3; j++) {
                setTimeout(() => {
                    // because of var j is defined only once,
                     and after that it's value just keeps on updating
                    console.log(j)
                }, 1);
            }

            /*
            output
            3
            3
            3
            */
            </code>
        </pre>
    </div>

    <div class="bg">
        <h1>Asynchronous callback</h1>
        <h5>Since JavaScript is synchronous, how is this handling those asynchronous events? </h3>
            <h3>JS first executes all the tasks in it's global execution task, in between if we do some <b>http request
                    or click event</b>, it gets stacked in <b>Event queue</b>. When js's stack gets empty it
                periodically looks into event queue and see if there is something. Then it runs all the items in event
                queue synchronously. </h3>
            <img src="./img/asynchronous.gif" class="responsive">
    </div>

    <div class="bg">
        <h1>Dynamic Typing</h1>
        <h3>It figures out variable type on the fly.</h3>
    </div>

    <div class="bg">
        <h1>Primitive Type</h1>
        <h3>A <b>type of data that holds single value</b>. So object is primitive type as it holds key value pairs.</h3>
        <h4>There are 6 primitive types:</h4>
        <ol>
            <li><b>Undefined</b> : Represents lack of existence. It is set by js engine sets variables to undefined
                initially. (Leave this value for engine to set)</li>

            <li><b>Null</b>: Represents lack of existence. Use this when we want to say somwthing does not exist or has
                no value. (We i.e. code will use this value to indicate that this does not exist.)</li>
            <li><b>Boolean</b>: True or false</li>
            <li><b>Number</b>: Floating point number. Int,decimal all accepted in number.</li>
            <li><b>String</b>: Sequence of characters in single '' of double "" quotes.</li>
            <li><b>Symbol</b>: Once you create a symbol, its value is kept private and for internal use.</li>
            <li><b>BigInt</b></li>
        </ol>
    </div>

    <div class="bg">
        <h1>Operator</h1>
        <h3>+ , - , * , / , >, <, etc </h3> <h3>This are as good as function which returns some value based on function
                name(operator)</h3>
        <h2><b>Infix notation</b>: The function name i.e. the operator sits between two parameters.
        </h2>

        <pre>
            <code>
                var a = 3 + 4;

                function +(a,b){
                    // return addition of a and b
                };
            </code>
        </pre>

        <p>So for calling this we would have to write something like</p>
        <pre>
            <code>
                +(3,4)  without infix notation

                3 + 4  -> infix notation (operator between two params)

                +3 -> prefix notation (operator before param)

                3+ -> postfix notation (operator after param)
            </code>
        </pre>
        <p>This does not seem good. That's why all programming languages have infix notation. </p>
    </div>

    <div class="bg">
        <h1>Operator Precedence</h1>
        <h3>It means which operator function gets called first. For example <b>()</b> will be given more priority over
            <b>*</b> which in turn will be called before <b>+</b></h3>
        <p>There's complete list of order od precedence. <a href="./order-of-precedence.pdf" target="_blank"> Click here
                to view.</a></p>
        <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Operator_Precedence"
            target="_blank">Get detailed explanation here.</a>
        <pre>
                    <code>
                        var a = 3 + 4 * 5;
                        console.log(a);

                        // output -> 23

                        var b = (3 + 4) * 5;
                        console.log(b);

                        // output -> 35
                    </code>
                </pre>
    </div>


    <div class="bg">
        <h1>Associativity</h1>
        <h3>If all operators / functions are same then in what order will the be called, i.e. from left-to-right or
            right-to-left.</h3>
        <h4>For e.g. ..*.., ../.., ..%.. all have same precedence. In such case this will be called from left-to-right.
        </h4>

        <pre>
                <code>
                        all have same precedence so called left to right

                        var c = 2 * 10 / 4;

                        console.log(c); // 5

                        var d = 2 / 10 * 4;

                        console.log(d); // 0.8
                </code>
            </pre>
        <a href="./order-of-precedence.pdf" target="_blank"> Click here
            to view.</a>
        <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Operator_Precedence"
            target="_blank">Get detailed explanation here.</a>
    </div>

    <div class="bg">
        <h1>Coercion</h1>
        <h3>Converting a value from one type to another. Since JS is Dynamically typed this happens a lot in js.</h3>
        <pre>
            <code>
                var a = "1" + 2;
                console.log(a); // 12

                var b = 4 + "1" + 2;
                console.log(b); // 412

                var c = 3 + 5 + 9 + "2";
                console.log(c); // 172

                var d = '3' + 5 + 9 + "2";
                console.log(d); // 3592
            </code>
        </pre>
    </div>

    <div class="bg">
        <h1>Comparison</h1>
        <h3>
            <b>==</b> coerces the value for Comparison, i.e. they just check value whereas <b>===</b> does not coerce
            value, checks value asa well as type;
        </h3>
        <h4>Strict Equality Comparison (===): used by Array.prototype.indexOf, Array.prototype.lastIndexOf, and
            case-matching</h4>
        <a href="./comparison.pdf" target="_blank">Refer this table to know more</a>
        <a href="https://dorey.github.io/JavaScript-Equality-Table/unified/" target="_blank">Refer this table to know
            more</a>
        <a href="https://github.com/slikts/js-equality-game">Game for js equality check.</a>
        <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Equality_comparisons_and_sameness"
            target="_blank">In depth explanation</a>
    </div>

    <div class="bg">
        <h1>Objects and dot notation</h1>
        <h3>An object can have:
            <br> <br>
            1. primitive i.e. boolena, string, number
            <br> <br>
            2. key value pairs ->
            <br> <br>
            <code>
                var a : { b : c { d : { e : 1}}};
            </code>
            <br> <br>
            3. methods (functions)
            <br>
            <code>
                var a = {
                read : function(){
                console.log('read');
                }
                }
            </code>
        </h3>

        <h3>Bracket notation is also called computed member access -> it has highest precendence after ()</h3>

        <h3> Dot notation is also called member access -> it has highest precendence after () </h3>
    </div>

    <div class="bg">
        <h1>Namespace</h1>
        <h3>In modern coding, a namespace is a container for variables and functions. It's just a holder, a container.
            And typically it's used to keep variables and functions with the same name separate.</h3>

        <h5>For.eg.</h5>

        <pre>
                <code>
                    var greet = 'Hello';
                    var greet = 'Hola';
                    
                    consloe.log(greet); //Hola

                    var english = {
                        greetings : {
                            greet : 'Hello'
                        }
                    };

                    var spanish = {
                        greetings : {
                            greet : 'Hola'
                        }
                    };

                    consloe.log(english.greetings.greet); // Hello
                    consloe.log(spanish.greetings.greet); // Hola

                </code>
            </pre>

        <h3>
            Before the greet variable was overrided and this can cause error.
            Since JS does not have namespace. So we created fake name space i.e.
            container for each language.</h3>

        <h4>I've contained my variables, maybe my functions and methods, and
            other objects, inside a container object, and that's all it's really doing.</h4>
    </div>

    <div class="bg">
        <h1>JavaScript Object Notation (JSON)</h1>
        <h3>It is a string of data looks just like object literal syntaxt ({ "a" : 2}). All properties are wrapped in
            quotes.</h3>
        <h3>JSON is more strict. It requires you to put properties in quotes. And does not allow to put values as
            functions inside it. It is used to pass from client in browser to server.</h3>

        <pre>
            <code>

                <!-- JSON -->
                '{
                    "firstName" : "Khushbu",
                    "isPerson" : true
                }'

                <!-- Object -->
                {
                    firstName :  "Khushbu",,
                    isPerson : true
                }
            </code>
        </pre>
    </div>

    <div class="bg">
        <h1>Expressions</h1>
        <h3>Anything that returns a value</h3>


        <pre>
            <code>
                        1 + 3
                        // 3
           </code>
    </pre>
    </div>

    <div class="bg">
        <h1>Function is an object in js.</h1>
    </div>

    <div class="bg">
        <h1>Anonymous Function</h1>
        <h3>It is a function that does not have name in it's name property. E.g.</h3>

        <pre>
            <code>
                // anonymous function
                var anonymousGreetFunction = function(){
                        console.log('Hi user!');
                }

                anonymousGreetFunction();  // Invocation
            </code>
        </pre>

        <h2>We cannot invoke anonymous function before it is declared, because functions are completely stores in memory
            while hoisting but in case of variables they are stored in memory with undefined value. So if we call it
            before it is executed we will get error. </h2>
        <b>Error : Cannot access 'anonymousGreetFunction' before initialization</b>
        <h3>Here function is not referenced by name but by a variable which knows where this function sit. As it has no
            name it is called anonymous. This is function expression</h3>
    </div>

    <div class="bg">
        <h1>Function expression</h1>
        <pre>
            function log(a) {
                a();
            }
            
            
            log(function () {
                console.log('Hi from log function')
            });
        </pre>

        <h3>a function expression creates an object, a function object on the fly.
            create function on fly, put some code in it and Pass it to another function which is then referenced by
            argument and then execute it.</h3>
    </div>

    <div class="bg">
        <h1>By value vs By Reference</h1>
        <h3>All primitive types gets referenced by value. Whereas on case of non-primitives i.e. objects value gets
            copied by reference.</h3>

        <b>All primitive types are by value and all objects are by reference.</b>

        <pre>
            <code>
                // by value (primitive)
                var a = 3;
                var b;
                b = a;

                /* here both a and b are 3, but there are two copies in memomry with value 3,
                 so if we now change value of a it would not change value of b */

                // by pointer - reference (non- primitive)
                var c = { someVal : 1};
                var d;
                c = d;

                // whereas here both c and d are pointing to same address in memory.
        </code>
    </pre>

        <b>Refer value-vs-reference.js file for more details.</b>
    </div>

    <div class="bg">
        <h1>Mutate : Something which can be changed. To change something.</h1>
        <h1>Immutable : Something which cannot be changed</h1>
    </div>

    <div class="bg">
        <h1>THIS</h1>
        <h3><b>This</b> keyword usually refers to global object in browser. When execution context is created, a this
            keyword is also created for it. </h3>
        <a href="./js/this-keyword.js" target="_blank">Refer for notes here</a>
    </div>

    <div class="bg">
        <h1>Array</h1>
        <h3>Array is a collection of object and primitive types. It is Dynamically typed.</h3>

        <a href="./js/array.js" target="_blank">Refer here for example</a>
    </div>

    <div class="bg">
        <h1>IIFE : Immediately Invoked Function Expression</h1>
        <h3>Function is called as soon as it is created.</h3>
        <h3>IIFE, it needs to be an anonymous function, a function without a name, this is because IIFE needs to be
            Invoked Immediately without invoking it a function name. We also need to wrap the anonymous function with
            parenthesis, so the Javascript parser treats our anonymous function as a function expression.

            <pre>
                <code>
                    (function() {
                        console.log('hi from iife');
                    }());
                </code>
            </pre>

            A function expression is when you assign a function to a variable or property of an object. Anything that is
            a Javascript expression, including function expression, returns a value.</h3>
    </div>

    <div class="bg">
        <h1>Closures</h1>

        <pre>
            <code>
                function greet(whatToSay){
                    return function(name){
                        console.log(`${whatToSay} ${name}`);
                    }
                }
                
                greet('Hello')('Khushbu');
                
                let greetings = greet('Namaste');
                greetings('Chandler');
                
                
                /*
                output 
                
                Hello Khushbu
                Namaste Chandler
                
                */
            </code>
        </pre>
        <ol>
            <li>We called <b>greet function</b> with paramter "Khushbu" / "Chandler". </li>
            <li>An <b>exection context is created</b> for greet function</li>
            <li>Memory space is created for <b>whatToSay</b></li>
            <li>Now anonymous function is returned (which consoles 2 variables whatToSay & name)</li>
            <li>After this the the execution context of <b>greet function</b> is <b>popped off the stack</b>.</li>
            <li>So now -> greet('Hello') is replaced with function returned. To invoke this function we wrote <b>
                    greet('Hello')('Khushbu'); / greetings('Chandler');</b></li>

            <li>The inner function does not have it's own <b>whatToSay</b> variable. So following scope chain it goes to
                outer function.</li>
            <li>Javascript normally destorys all the variables defined inside function when it is popped out of context.
                But in this cases like above the variable still lives.</li>
            <li>The inner function still can reference to the all the vairables it need.</li>
            <li>So our anonymous function call still reference to <b>whatToSay</b> variable.</li>

            <li>The JavaScript engine will always make sure that whatever function I'm running,

                that it will have access to the variables that it's supposed to have access to. </li>
        </ol>

        <h3>Greet is gone, the execution context is gone. <br>

            But what's in memory for that execution context isn't and the <br>

            JavaScript engine makes sure that my function can still go down the scope chain and find it. <br>

            Even though it's not even on the execution stack anymore.
            <br>
            And this way we say that the execution context has closed in its outer variables, <br>

            the variables that it would normally have reference to anyway. <br>

            Even though those execution contexts are gone. <br>

            And so this phenomenon, of it closing in all the variables <br>

            that it's supposed to have access to, is called a closure.</h3>

            <a href="./js/closure.js" target="_blank">Refer for exmaples</a>
    </div>
</body>

</html>