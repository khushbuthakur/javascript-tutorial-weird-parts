<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Javascript - Weird Parts</title>
    <link rel="stylesheet" href="./style.css">
</head>

<body>
    <div class="bg">
        <h1>Syntax parser</h1>
        <h3>A program that reads js code and translates it to computer readable language.</h3>
        <br />
    </div>

    <div class="bg">
        <h1>Lexical Environment</h1>
        <h3>Where something sits physically in the code you write.<br />
            Lexical Environment exists in which <b>where</b> you write something is important.

            It basically tells where is it written and what surrounds it.

            For example:
            <pre>
        <code>
            var b = "b";

            function abc(){
                 var a = 'a';
            }
        </code>
    </pre>
            <h4> Here <b>variable b</b> is globally available but <b>variable a</b> is available only inside <b>function
                    abc</b>
                that is <b>lexical scope</b> of variable b</h4>
        </h3>

        <br />
    </div>

    <div class="bg">
        <h1>Execution context</h1>
        <h3><b>A wrapper to help manage the code that is running.</b>
            There are lot of lexical environments but <b>which one is running currently</b> is managed by Execution
            code.
            <br />
            It not only contains our code but it also contains things written by syntax parser to run code.
        </h3>

        <br>

        <h1>Objects</h1>
        <h3>Collection of name value pairs

            <pre>
            <code>
                let address = {
                    street : 'Main',
                    apartment : {
                        floor : 2,
                        number : 100
                    }
                };
            </code>
        </pre>

            Here address, street, apartment, floor and number are all name and respective to right their values.
            Value can itself be another object.
        </h3>
    </div>


    <div class="bg">
        <h1>Execution context - GLOBAL</h1>
        <h3>Javascript engine creates <b>Global Object</b> and variable <b>this</b> (setup in memory) whenever our code
            runs because code
            in wrapped inside <i>execution context</i></h3>
    </div>

    <div class="bg">
        <h1>Hoisting</h1>
        <h3>Javascript engine moves functions and variables to the top of the code
            E.g.
            <pre>
                <code>
                    b();

                    console.log(a);
                    
                    var a = "a val";

                    function b(){
                        console.log('b function called');
                    }

                    //output
                  ->  b function called
                  -> undefined

                </code>
            </pre>
            <p>here a and b both are called before they are declared. but still there is no error in console because
                they are moved to the top</p>
        </h3>
        <h3>
            There are <b>two phases</b> which happen during execution;
            <ul type="none">
                <li>
                    1. Creation phases
                </li>
                <li>
                    2. Execution phase
                </li>
            </ul>
            <ul>
                <li> 1. During creation phase -> global object is setup within memory. </li>
                <li> 2. Parser recognizes where we have created variables and functions. </li>
                <li> 3. Set asides memory space for them </li>
                <li> 4. Function is entirely placed in memory i.e. both function and logic inside it </li>
                <li> 5. Whereas in case of variables it only sets memory space and sets value as undefined as it don't
                    know what's it value will be until it is executed
                    i.e. it assigns undefined placeholder for it </li>
            </ul>

            <b>All variables in javascript are initially set to undefined and functions are sitting in memory
                entirely.</b>
            </h5>

            <p>if we use let instead of var then it will throw error instead of showing undefined and will say <br>
                <b> ------------ Cannot access 'a' before initialization ---------</b></p>
    </div>

    <div class="bg">
        <h1>Single threaded - synchronous execution</h1>
        <h3>Single threaded : One command is executed at a time.</h3>
        <h3>synchronous : one at a time and in order that it appears.</h3>
    </div>

    <div class="bg">
        <h1>Invocation</h1>
        <h3>Running a function { by using paranthesis() }. So when we say invoke the function we mean to say run the
            function.</h3>

        <b>So whenever we invoke a function a new execution context is created and put on the top of the stack. The
            execution context on the top is always executed currently.</b>

        <p> When function is executed it gets poped out from the stack.</p>
        <div>
            <img src="./img/function-invocation.gif" class="responsive" />
        </div>
    </div>

    <div class="bg">
        <h1>Scope Chain</h1>
        <img src="./img/scope-chain.png" class="responsive">

        <h3>If we call same function twice, each will get it's own execution context.</h3>
    </div>

    <div class="bg">
        <h1>Scope</h1>

        <h3>Where a variable is available in the code.</h3>
        <h3><b>let</b> is block scope. It is only available inside the current function.</h3>
        <pre>
            <code>
                function a(){
                    let b = true;
                    var c = false;
                }
            </code>
        </pre>

        <h3> <b>let is same as var.</b> It is declared, set to undefined and stored in the memory. <b>However we can't
                use it until the line of code is actually run</b></h3>

        <h4>In above example if we call b variable before it's declaration, it throws reference error.</h4>
        <h3><u>Variable c is available outside <code>function a</code> but variable b is not available as it is declared
                using let. And let is block scoped.</u></h3>
        <h5>A block's in general defined by curly braces. Eg. if statement, for loop, function</h5>
    </div>

    <div class="bg">
        <h1>Asynchronous callback</h1>
        <h5>Since JavaScript is synchronous, how is this handling those asynchronous events? </h3>
            <h3>JS first executes all the tasks in it's global execution task, in between if we do some <b>http request
                    or click event</b>, it gets stacked in <b>Event queue</b>. When js's stack gets empty it
                periodically looks into event queue and see if there is something. Then it runs all the items in event
                queue synchronously. </h3>
            <img src="./img/asynchronous.gif" class="responsive">
    </div>

    <div class="bg">
        <h1>Dynamic Typing</h1>
        <h3>It figures out variable type on the fly.</h3>
    </div>

    <div class="bg">
        <h1>Primitive Type</h1>
        <h3>A <b>type of data that holds single value</b>. So object is primitive type as it holds key value pairs.</h3>
        <h4>There are 6 primitive types:</h4>
        <ol>
            <li><b>Undefined</b> : Represents lack of existence. It is set by js engine sets variables to undefined
                initially. (Leave this value for engine to set)</li>

            <li><b>Null</b>: Represents lack of existence. Use this when we want to say somwthing does not exist or has
                no value. (We i.e. code will use this value to indicate that this does not exist.)</li>
            <li><b>Boolean</b>: True or false</li>
            <li><b>Number</b>: Floating point number. Int,decimal all accepted in number.</li>
            <li><b>String</b>: Sequence of characters in single '' of double "" quotes.</li>
            <li><b>Symbol</b>: Once you create a symbol, its value is kept private and for internal use.</li>
        </ol>
    </div>

    <div class="bg">
        <h1>Operator</h1>
        <h3>+ , - , * , / , >, <, etc </h3> <h3>This are as good as function which returns some value based on function
                name(operator)</h3>
        <h2><b>Infix notation</b>: The function name i.e. the operator sits between two parameters.
        </h2>

        <pre>
            <code>
                var a = 3 + 4;

                function +(a,b){
                    // return addition of a and b
                };
            </code>
        </pre>

        <p>So for calling this we would have to write something like</p>
        <pre>
            <code>
                +(3,4)  without infix notation

                3 + 4  -> infix notation (operator between two params)

                +3 -> prefix notation (operator before param)

                3+ -> postfix notation (operator after param)
            </code>
        </pre>
        <p>This does not seem good. That's why all programming languages have infix notation. </p>
    </div>

    <div class="bg">
        <h1>Operator Precedence</h1>
        <h3>It means which operator function gets called first. For example <b>()</b> will be given more priority over
            <b>*</b> which in turn will be called before <b>+</b></h3>
        <p>There's complete list of order od precedence. <a href="./order-of-precedence.pdf" target="_blank"> Click here
                to view.</a></p>
        <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Operator_Precedence"
            target="_blank">Get detailed explanation here.</a>
        <pre>
                    <code>
                        var a = 3 + 4 * 5;
                        console.log(a);

                        // output -> 23

                        var b = (3 + 4) * 5;
                        console.log(b);

                        // output -> 35
                    </code>
                </pre>
    </div>


    <div class="bg">
        <h1>Associativity</h1>
        <h3>If all operators / functions are same then in what order will the be called, i.e. from left-to-right or
            right-to-left.</h3>
        <h4>For e.g. ..*.., ../.., ..%.. all have same precedence. In such case this will be called from left-to-right.
        </h4>

        <pre>
                <code>
                        all have same precedence so called left to right

                        var c = 2 * 10 / 4;

                        console.log(c); // 5

                        var d = 2 / 10 * 4;

                        console.log(d); // 0.8
                </code>
            </pre>
        <a href="./order-of-precedence.pdf" target="_blank"> Click here
            to view.</a>
        <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Operator_Precedence"
            target="_blank">Get detailed explanation here.</a>
    </div>

    <div class="bg">
        <h1>Coercion</h1>
        <h3>Converting a value from one type to another. Since JS is Dynamically typed this happens a lot in js.</h3>
        <pre>
            <code>
                var a = "1" + 2;
                console.log(a); // 12

                var b = 4 + "1" + 2;
                console.log(b); // 412

                var c = 3 + 5 + 9 + "2";
                console.log(c); // 172

                var d = '3' + 5 + 9 + "2";
                console.log(d); // 3592
            </code>
        </pre>
    </div>

    <div class="bg">
        <h1>Comparison</h1>
        <h3>
            <b>==</b> coerces the value for Comparison, i.e. they just check value whereas <b>===</b> does not coerce
            value, checks value asa well as type;
        </h3>
        <h4>Strict Equality Comparison (===): used by Array.prototype.indexOf, Array.prototype.lastIndexOf, and
            case-matching</h4>
        <a href="./comparison.pdf" target="_blank">Refer this table to know more</a>
        <a href="https://dorey.github.io/JavaScript-Equality-Table/unified/" target="_blank">Refer this table to know
            more</a>
        <a href="https://github.com/slikts/js-equality-game">Game for js equality check.</a>
        <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Equality_comparisons_and_sameness"
            target="_blank">In depth explanation</a>
    </div>

    <div class="bg">
        <h1>Objects and dot notation</h1>
        <h3>An object can have:
            <br> <br>
            1. primitive i.e. boolena, string, number
            <br> <br>
            2. key value pairs ->
            <br> <br>
            <code>
                var a : { b : c { d : { e : 1}}};
            </code>
            <br> <br>
            3. methods (functions)
            <br>
            <code>
                var a = {
                read : function(){
                console.log('read');
                }
                }
            </code>
        </h3>

        <h3>Bracket notation is also called computed member access -> it has highest precendence after ()</h3>

        <h3> Dot notation is also called member access -> it has highest precendence after () </h3>
    </div>

</body>

</html>